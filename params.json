{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"OpenCL Mid-Level Abstractions Project","name":"OCL-MLA","body":"# What is OCL-MLA?\r\nOCL-MLA is exactly what its name implies: a mid-level set of abstractions to make OpenCL development easier.  OCL-MLA provides a set of compile-time configurable _logical_ devices that are mapped to actual node-level device resources.  This removes the normal boiler-plate configuration that many people find intimidating and tedious.  Logical devices are pre-configured (think MPI_COMM_WORLD communicator) and initialized with a single call to _ocl\\_init()_.  OCL-MLA insulates the application developer from differences in particular compute devices accessed by the OpenCL runtime, while still allowing an expert OpenCL administrator to choose how each physical device is configured and used.  Additionally, OCL-MLA provides a convenience hash-table interface for creating and accessing OpenCL constructs such as kernels, programs and buffers.  OCL-MLA supports C and **Fortran** APIs.\r\n\r\n# Features\r\n* Compile-time logical device configuration\r\n* Hash interface for creating and managing OpenCL tokens\r\n* **Fortran bindings**\r\n* Timer utilities\r\n* Support for multiple OpenCL platforms in single configuration _(ICD - installable client driver)_\r\n* Convenience functions for event manipulation\r\n* Utilities for program manipulation, e.g., static compilation of input kernel source code\r\n\r\n# Example\r\n```C\r\nconst size_t ELEMENTS = 32;\r\n\r\nint main(int argc, char ** argv) {\r\n   size_t global_size = ELEMENTS;\r\n\r\n   // initialize OpenCL runtime\r\n   ocl_init();\r\n\r\n   // create a host-side array\r\n   float h_array[ELEMENTS];\r\n\r\n   // initialize host-side array\r\n   for(size_t i=0; i<ELEMENTS; ++i) {\r\n      h_array[i] = 0.0;\r\n   } // for\r\n\r\n   // create a device-side array\r\n   ocl_create_buffer(OCL_PERFORMANCE_DEVICE, \"array\", ELEMENTS*sizeof(float),\r\n      CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, h_array);\r\n\r\n   // create program source from static input string\r\n   char * source = NULL;\r\n   ocl_add_from_string(test_PPSTR, &source, 0);\r\n\r\n   // add program\r\n   ocl_add_program(OCL_PERFORMANCE_DEVICE, \"program\", source, \"-DMY_DEFINE\");\r\n   free(source);\r\n\r\n   // add kernel\r\n   ocl_add_kernel(OCL_PERFORMANCE_DEVICE, \"program\", \"test\", \"my test\");\r\n\r\n   // use hints interface to decide what work-group size to use\r\n   ocl_kernel_hints_t hints;\r\n   size_t work_group_indeces;\r\n   size_t single_indeces;\r\n\r\n   // get kernel hints\r\n   ocl_kernel_hints(OCL_DEFAULT_DEVICE, \"program\", \"my test\", &hints);\r\n\r\n   // heuristic for how to execute global_size work-items\r\n   ocl_ndrange_hints(global_size, hints.max_work_group_size,\r\n      0.5, 0.5, &local_size, &work_group_indeces, &single_indeces);\r\n\r\n   // set kenerl argument\r\n   ocl_set_kernel_arg_buffer(\"program\", \"my test\", \"array\", 0);\r\n\r\n   // initialize event for timings\r\n   ocl_initialize_event(&event);\r\n\r\n   // invoke kernel\r\n   ocl_enqueue_kernel_ndrange(OCL_PERFORMANCE_DEVICE, \"program\",\r\n      \"my test\", 1, &global_offset, &global_size, &local_size, &event);\r\n\r\n   // block for kernel completion\r\n   ocl_finish(OCL_PERFORMANCE_DEVICE);\r\n\r\n   // add a timer event for the kernel invocation\r\n   ocl_add_timer(\"kernel\", &event);\r\n\r\n   // read data from device\r\n   ocl_enqueue_read_buffer(OCL_PERFORMANCE_DEVICE, \"array\", 1, offset,\r\n      ELEMENTS*sizeof(float), h_array, &event);\r\n\r\n   // print data read from device\r\n   for(size_t i=0; i<ELEMENTS; ++i) {\r\n      fprintf(stderr, \"%f\\n\", h_array[i]);\r\n   } // for\r\n   fprintf(stderr, \"\\n\");\r\n\r\n   // print timer results\r\n   ocl_report_timer(\"kernel\");\r\n\r\n   // finalize OpenCL runtime\r\n   ocl_finalize();\r\n}\r\n```","google":""}