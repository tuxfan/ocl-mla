#! /usr/bin/env python
#------------------------------------------------------------------------------#
# Copyright (c) 2012 Los Alamos National Security, LLC
# All rights reserved.
#------------------------------------------------------------------------------#

import subprocess
import re
import os.path
import sys
import argparse

#------------------------------------------------------------------------------#
# write C-style output
#------------------------------------------------------------------------------#

def write_c(fd, sp0):
	fd.write('/*\n')
	fd.write(' * THIS FILE WAS GENERATED BY ' +
		'utils/stringify_kernel_files DO NOT EDIT\n')
	fd.write(' */\n\n')

	output_define = re.sub('\.', '_', fd.name)
	fd.write('#ifndef ' + output_define + '\n')
	fd.write('#define ' + output_define + '\n\n')

	#---------------------------------------------------------------------------#
	# process files
	#---------------------------------------------------------------------------#

	for inputname in sp0.stdout.readlines():

		#------------------------------------------------------------------------#
		# strip comments from file
		#------------------------------------------------------------------------#

		sp1 = subprocess.Popen(["cpp -fpreprocessed -dD -E " +
			inputname.rstrip() + " | sed 's,# .*,,g'"],
			stdout=subprocess.PIPE, shell=True)		

		#------------------------------------------------------------------------#
		# create string name and begin output
		#------------------------------------------------------------------------#

		charname = re.sub('^.*\/', '', re.sub('\.cl', '', inputname.rstrip()))

		fd.write('const char * ' + charname + '_PPSTR = \n')

		for line in sp1.stdout.readlines():
			if len(line.rstrip()) == 0:
				continue

			line = re.sub('\"', '\\"', re.sub('\\\\', '\\\\\\\\', line.rstrip()))
			fd.write('\"' + line + ' \\n\"\n')

		fd.write(';\n\n')

	#---------------------------------------------------------------------------#
	# cleanup
	#---------------------------------------------------------------------------#

	fd.write('#endif // ' + output_define + '\n')
	fd.close()
# write_c

#------------------------------------------------------------------------------#
# write C-style output
#------------------------------------------------------------------------------#

def write_fortran(fd, sp0):
	fd.write('!---------------------------------------' +
		'---------------------------------------!\n')
	fd.write('! THIS FILE WAS GENERATED BY ' +
		'utils/stringify_kernel_files DO NOT EDIT\n')
	fd.write('!---------------------------------------' +
		'---------------------------------------!\n\n')

	module = re.sub('\..*$', '', fd.name)
	fd.write('   module ' + module + '\n\n')

	#---------------------------------------------------------------------------#
	# process files
	#---------------------------------------------------------------------------#

	for inputname in sp0.stdout.readlines():

		#------------------------------------------------------------------------#
		# strip comments from file
		#------------------------------------------------------------------------#

		sp1 = subprocess.Popen(["cpp -fpreprocessed -dD -E " +
			inputname.rstrip() + " | sed 's,# .*,,g'"],
			stdout=subprocess.PIPE, shell=True)		

		#------------------------------------------------------------------------#
		# create string name and begin output
		#------------------------------------------------------------------------#

		charname = re.sub('^.*\/', '', re.sub('\.cl', '', inputname.rstrip()))

		fd.write('   character, parameter :: ' + charname + '_PPSTR = &\n')

		for line in sp1.stdout.readlines():
			if len(line.rstrip()) == 0:
				continue

			line = re.sub('\"', '\\"', re.sub('\\\\', '\\\\\\\\', line.rstrip()))
			fd.write('      \'' + line + ' \\n\' &\n')

		fd.write('\n')

	#---------------------------------------------------------------------------#
	# cleanup
	#---------------------------------------------------------------------------#

	fd.write('   end module ' + module + '\n')
	fd.close()
# write_fortran

#------------------------------------------------------------------------------#
# parse command-line arguments
#------------------------------------------------------------------------------#

parser = argparse.ArgumentParser(description='Create static strings from OpenCL kernel files.')
parser.add_argument('--lang', '-l', required=True, choices=('C', 'Fortran'))
parser.add_argument('directory')
parser.add_argument('output', type=argparse.FileType('w'))

args = parser.parse_args()

#------------------------------------------------------------------------------#
# find kernel files (.cl)
#------------------------------------------------------------------------------#

sp0 = subprocess.Popen(["find " + str(args.directory) + " -regex '.*\.cl'"],
	stdout=subprocess.PIPE, shell=True)

if args.lang == 'C':
	write_c(args.output, sp0)
else:
	write_fortran(args.output, sp0)

