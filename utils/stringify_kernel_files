#! /usr/bin/env python
#------------------------------------------------------------------------------#
# Copyright (c) 2012 Los Alamos National Security, LLC
# All rights reserved.
#------------------------------------------------------------------------------#

import subprocess
import re
import os.path
import sys
import argparse

#------------------------------------------------------------------------------#
# write c-style file header
#------------------------------------------------------------------------------#

def write_c_header(fd):
	fd.write('/*\n')
	fd.write(' * THIS FILE WAS GENERATED BY ' +
		'utils/stringify_kernel_files DO NOT EDIT\n')
	fd.write(' */\n\n')

#------------------------------------------------------------------------------#
# write C-style output
#------------------------------------------------------------------------------#

def write_c(name, sp0):
	fd_h = open(name + '.h', 'w')
	fd_c = open(name + '.c', 'w')

	write_c_header(fd_h)
	write_c_header(fd_c)

	# write header defines
	output_define = re.sub('^.*\/', '', os.path.splitext(fd_h.name)[0] + '_h')
	fd_h.write('#ifndef ' + output_define + '\n')
	fd_h.write('#define ' + output_define + '\n\n')

	#---------------------------------------------------------------------------#
	# process fiels
	#---------------------------------------------------------------------------#

	for inputname in sp0.stdout.readlines():

		#------------------------------------------------------------------------#
		# strip comments from file
		#------------------------------------------------------------------------#

		sp1 = subprocess.Popen(["cpp -fpreprocessed -dD -E " +
			inputname.rstrip() + " | sed 's,# .*,,g'"],
			stdout=subprocess.PIPE, shell=True)		

		#------------------------------------------------------------------------#
		# create string name and begin output
		#------------------------------------------------------------------------#

		charname = re.sub('^.*\/', '', re.sub('\.cl', '', inputname.rstrip()))

		fd_h.write('/* ' + inputname.rstrip() + ' */\n')
		fd_h.write('extern const char * ' + charname + '_PPSTR;\n')

		fd_c.write('/* ' + inputname.rstrip() + ' */\n')
		fd_c.write('const char * ' + charname + '_PPSTR = \n')

		for line in sp1.stdout.readlines():
			if len(line.rstrip()) == 0:
				continue

			line = re.sub('\"', '\\"', re.sub('\\\\', '\\\\\\\\', line.rstrip()))

			if len('\"' + line + '\\n\"\n') > 70:
				fd_c.write('\"' + line[0:41] + '\"\n')
				fd_c.write('\"' + line[41:len(line)] + '\\n\"\n')
			else:
				fd_c.write('\"' + line + '\\n\"\n')
		# for

		fd_h.write('\n')
		fd_c.write('\"\\n\"\n')
		fd_c.write(';\n\n')
	# for

	#---------------------------------------------------------------------------#
	# cleanup
	#---------------------------------------------------------------------------#

	fd_h.write('#endif // ' + output_define + '\n')
	fd_h.close()
	fd_c.close()
# write_c

#------------------------------------------------------------------------------#
# write Fortran-style output
#------------------------------------------------------------------------------#

def write_fortran(name, sp0):
	fd = open(name + '_f.f90', 'w')

	fd.write('!---------------------------------------' +
		'---------------------------------------!\n')
	fd.write('! THIS FILE WAS GENERATED BY ' +
		'utils/stringify_kernel_files DO NOT EDIT\n')
	fd.write('!---------------------------------------' +
		'---------------------------------------!\n\n')

	module = re.sub('^.*\/', '', os.path.splitext(name)[0])
	fd.write('   module ' + module + '\n')
	fd.write('      use, intrinsic :: ISO_C_BINDING\n\n')

	#---------------------------------------------------------------------------#
	# process files
	#---------------------------------------------------------------------------#

	for inputname in sp0.stdout.readlines():

		#------------------------------------------------------------------------#
		# create string name and begin output
		#------------------------------------------------------------------------#

		charname = re.sub('^.*\/', '', re.sub('\.cl', '', inputname.rstrip()))

		fd.write('      character(c_char), bind(c, name=\"' +
			charname + '_PPSTR\") :: ' + charname + '_PPSTR\n')
	# for

	#---------------------------------------------------------------------------#
	# cleanup
	#---------------------------------------------------------------------------#

	fd.write('\n   end module ' + module + '\n')
	fd.close()
# write_fortran

#------------------------------------------------------------------------------#
# parse command-line arguments
#------------------------------------------------------------------------------#

parser = argparse.ArgumentParser(description='Create static strings from OpenCL kernel files.')
parser.add_argument('-f', '--fortran', action="store_true")
parser.add_argument('directory')
parser.add_argument('output')

args = parser.parse_args()

#------------------------------------------------------------------------------#
# find kernel files (.cl)
#------------------------------------------------------------------------------#

devnull = open(os.devnull, 'w')

sp0 = subprocess.Popen(["find " + str(args.directory) + " -regex '.*\.cl'"],
	stdout=subprocess.PIPE, stderr=devnull, shell=True)

write_c(args.output, sp0)

sp0 = subprocess.Popen(["find " + str(args.directory) + " -regex '.*\.cl'"],
	stdout=subprocess.PIPE, stderr=devnull, shell=True)

if args.fortran:
	write_fortran(args.output, sp0)
